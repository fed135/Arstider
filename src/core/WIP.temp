
///////////////////////////////////////////////////////// WIP

	/**
	* @Name MovieClip
	* 
	* @Description Your basic display object. Pretty similar to the Flash element as it can contain graphic data and also MovieClips.
	*/
	/*declare("Graphics.MovieClip", [Graphics.DisplayObject,Graphics.DisplayObjectContainer], function(){
		
		//Public
		return {
			type:"MovieClip",
			play:function() {
				
			},
			stop:function() {
				
			},
			_animate:function () {
				
			},
			constructor:function(attr){
				//Pass info to Super constructors
				var 
					//_doc, //DisplayObjectContainer Ref
					//_do,	//DisplayObject
					p, 
					img, 
					propList, 
					//parent = this.parent;
				;
				
				//Try throwing the texture logic in DisplayObject.
				//_do = getInherited(arguments);
				//_doc = getInherited(arguments);
				
				//_do.apply(attr);
				//_doc.apply(attr);
				
				propList = attr || initAttributes;
				
				for(p in propList) {
					if (propList.hasOwnProperty(p)) {
						if(props[p] !== undefined) {
							if((propList[p] instanceof String || (typeof propList[p] === "string")) && (propList[p].indexOf(".jpg") || propList[p].indexOf(".png") || propList[p].indexOf(".gif"))) {
								img = new Image();
								console.warn(this);
								img.onload = function() {
									loaded = true;
									parent._update();
							    };
								img.src=propList[p];
								
								props[p] = img;
							}
							else {
								props[p] = propList[p];
							}
						}
						else {
							console.warn("Unknown propriety '"+p+"'");
						}
					}
				}
			}
		};
	}());*/

	/**
	* @Name Layer
	* 
	* @Description This is where MovieClips are assembled and flatten. 
	*	Layers are stacked one over another, like in Photoshop or Flash, so to add a z-index. 
	*	Beware, it cannot be transformed like the MovieClip.
	*/
	//Graphics.Layer = function(/*(String) Name*/name,/*(Object) Proprieties*/attributes) {
		/*
		var 
			//Private
			id = Date.now(),
			lastRender = 0,
			lastUpdate = Date.now(),
			clips = {},
			rendered = false,
			imgData = null,
			canvasObj = null,
			ctx = null,
			//Create canvas
			canvas = document.createElement('canvas'),
			ctx = null,
			props= {
					backgroundColor:null,
					engine:"2d",
					width:0,
					height:0
				}
		;
		
		canvas.setAttribute('class', 'arCanvasLayer');
		canvas.setAttribute('id', 'arCanvasLayer_'+id);
		
		function updateProps(propList) {
			for(p in propList) {
				if (propList.hasOwnProperty(p)) {
					if(props[p] !== undefined) {
						props[p] = propList[p];
					}
					else {
						console.warn("Unknown propriety '"+p+"'");
					}
				}
			}
		}
		
		function updateElement() {
			canvas.setAttribute('height', props.height);
			canvas.setAttribute('width', props.width);
			ctx = canvas.getContext(props.engine);
		}
		
		updateProps(attributes);
		updateElement();
		
		//Public
		return {
			type:"Layer",
			freeze:false,*/
			//addClip:function(/*(Clip) clip*/clip) {
				/*var id= clip.name || Date.now();
				clip.parent = this;
				clip.id = id;
				clips[id]=clip;
				clips[id].init();
				return id;
			},*/
			//removeClip:function(/*(String) clip*/clip) {
			/*	if(!(clip instanceof String) && !(typeof clip === "string")) {
					if(clip.id !=undefined){
						delete clips[clip.id];
						return true;
					}
				}
				else {
					delete clips[clip];
					return true;
				}
				return false;
			},
			_render:function() {
				if((lastUpdate - lastRender)>0 && this.freeze == false) {
					//clear
					ctx.clearRect(0,0,props.width,props.height);
					var d, t, itemcount = 0, rendercount = 0;
					for(d in clips) {
						++itemcount;
						if (clips.hasOwnProperty(d)) {
							t = clips[d]._data();
							if(t !== false) {
								console.warn("Rendering ("+rendercount+"/"+itemcount+")");
								ctx.drawImage(clips[d]._data(), clips[d]._x(), clips[d]._y());
								rendercount++;
							}
						}
					}
					if(itemcount == rendercount) {
						console.warn("Render stop");
						lastRender = Date.now();
					}
				}
			},
			
			_update:function() {
				lastUpdate = Date.now();
			},
			
			context:function() {
				return ctx;
			},
			canvas:function() {
				return canvas;
			},
			framerate:0,			//Not sure. What if we want to change it runtime ?
			visible:true,
			zIndex:0
		}
	}*/

	/**
	* @Name Canvas
	* 
	* @Description This is where layers are finaly rendered (flat) onto the scene with the appropriate engine.
	*/
	//Graphics.Canvas = function(/*(Dom Object) element*/elem) {
		
		/*var 
			//Private
			layers = {},
			counter=Date.now(),
			handBreak = false,
			state = "idle",
			drawEng = 1,
			sref = this,
			zIndexInc = 0,
			workbench = null,
			
			//Create Dom
			container = document.createElement('div')
		;
		
		container.setAttribute('height', elem.style.height);
		container.setAttribute('width', elem.style.width);
		container.setAttribute('class', 'arCanvasContainer');
		
		elem.appendChild(container);
		
		function _draw() {
			var l;
			if(handBreak == false){
				//Next call
				window.requestAnimFrame(_draw);
				
				//Perform draw
				for(l in layers) {
					if (layers.hasOwnProperty(l)) {
						layers[l]._render();
					}
				}
			}
			else{
				state = "stopped";
			}
		}
		
		//Public
		return {
			
			type:"Canvas",
			
			stopDraw:function(){
				handBreak = true;
				state = "stopping";
			},
			
			startDraw:function(){
				state = "drawing";
				window.requestAnimFrame(_draw);
			},
			
			_canvas:function(){
				return ctx;
			},
			
			_degradeEngine:function() {
				//Go down one notch, this browser doesn't have it in him.
				if(drawEng <engines.length-1) {
					drawEng++;
					this._applyEngine();
					return true;
				}
				return false;
			},
			
			_applyEngine:function() {
				console.log("Drawing engine changed to '"+engines[drawEng]+"'");
				ctx = canvas.getContext(engines[drawEng]);
				this._testDraw();
			},
			
			_activeLayer : null
		};
	}
	
	//Stacks of tasks to be performed on Animation Frame.
	/*Graphics._layerStack=[];
	Graphics._layerStack=[];
	
	Graphics._renderStack=function(){
		var a;
		for(a = 0; a<Graphics._stack.length; a++)
		{
			
		}
	}
	window.requestAnimFrame(Graphics._renderStack);*/
	
	
	//Allow AMD definition of Graphics
	//if (typeof define === "function" && define.amd) {
	//	define( "ar.core.Graphics", function () { return Graphics; } );
	//}

	
	//window.Ar.Graphics = Graphics;
	
	//Prototypes
	//Object.prototype.drawCanvas = function(){return Graphics.Canvas(this)};

//})(window);